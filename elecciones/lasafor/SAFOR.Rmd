---
title: "Ejemplo de R Markdown: *El voto autonómico en la comarca de la Safor (VALENCIA)* "
author: "Tomàs Ferrandis Moscardó"
date: "2024-01-26"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 4
    df_print: paged
    number_sections: false
  pdf_document:
    latex_engine: pdflatex
    toc: true
    keep_tex: true
---


# 1. INTRODUCCIÓN

A continuación veremos un sencillo ejemplo de uso de **R-Markdown** en el que, a partir de un fichero de tipo *csv* ( SAFOR.csv ) crearemos y manipularemos objetos _data.frame_.
Obtendremos algunas medidas de *tendencia central y dispersión* que representaremos en tablas y gráficos.

Después guardaremos los datos del data_frame de resultados en ficheros de diversos tipos:  *csv, xlsx, dta, RData, sav, rds)*

## 1.1 Inclusión de los paquetes ( y sus librerías) que vamos a necesitar

Las librerías se cargan solo si previamente se ha instalado el paquete que las contiene. En nuestros *chuncks* ( pedazos de código R), comprobaremos si están disponibles. Solo en caso contrario instalaremos su paquete correspondiente.

Para ello, primero se intenta cargar una librería mediante *require()* . Si da error, require devuelve un valor FALSE (!require()), entonces se ejecuta la instalación del paquete (que carga también la librería).

```{r 0, echo=TRUE}

# Requisitos previos. Paquetes de librerías
if (!require("dplyr")) {install.packages("dplyr")}
if (!require("stringr")) {install.packages("stringr")}
if (!require("curl")) {install.packages("curl")}
if (!require("rsconnect")){install.packages("rsconnect")}
if (!require("kableExtra")){install.packages("kableExtra")}
if (!require("tidyverse")){install.packages("tidyverse")}
if (!require("tidyverse")){install.packages("openxlsx")}
library(openxlsx)
library(dplyr)
library(data.table)
library(knitr)
library(ggplot2)
```

# 2. OBTENCIÓN Y TRATAMIENTO DE LOS DATOS

## 2.1 Resultados de todas las elecciones y convocatorias a nivel de agregación comarcal. Caso de La Safor.

A partir de la base de datos de ARGOS descargamos el resumen de resultados electorales en las distintas convocatorias y procesos electorales en un fichero *CSV*.

```{r 1, echo=TRUE}
  df1<-read.csv("CSV/SAFOR.csv",header=TRUE, sep=",",quote="\"'", dec=",",fill=TRUE,
                comment.char = "")
  # View(df1) # Para ver en consola
```

Veamos como ejemplo las primeras líneas con la función *head*

```{r 1b, echo=TRUE}
head(df1)
```

## 2.2 Filtramos por elecciones autonómicas.

Asumimos como **universo o población** el conjunto de todas las todas elecciones autonómicas. 

## Filtraremos por el campo correspondiente

En nuestro caso las elecciones autonómicas. Selleccionamos las que el campo *Elecció* empiece por 'A'
```{r 2, echo=TRUE}
df_autonomicas<-df1 %>% filter(str_detect(df1$Elecció,"A-"))
```

## 2.3 Vemos las primeras lineas de ejemplo

Algunos ejemplos de uso de funciones de lectura. Ver las 3 primeras filas o las 2 últimas del data frame
```{r 2b, true=TRUE}
head(df_autonomicas,3)
tail(df_autonomicas,2)
```

## 2.4 Tratamiento de los NA
 
 **¿Qué valores serán no válidos a efectos estadísticos?**

En nuestro caso los NA se deben a la ausencia de resultados por no haberse presentado la fuerza política en una convocatoria o por haberse integrado en una coalición electoral. Entendemos que el valor que debe sustituir NA para poder realizar cálculos estadísticos de forma correcta y sin errores de computación es el 0. Podríamos recorrer solo las columnas de partidos pero lo simplificamos y aplicamos la sustitución NA -\> 0 en todo el data frame.

```{r 3, echo=TRUE}
df_autonomicas[is.na(df_autonomicas)]<-0
```

Mostramos los datos en formato de tabla de RMarkdown

```{r 3b, echo=TRUE}
#kable es una función del paquete knitr que permite formatear tablas. Existen más alternativa
kable(df_autonomicas, caption = "ELECCIONES AUTONÓMICAS EN LA SAFOR")
```
 
## 2.5 Creamos un vector con las candidaturas.

```{r 4, echo=TRUE}
# Recogemos los nombres de columnas a partir de la 4ª columna
partits<-names(df1[4:length(df1)])
# Para nuestro caso podríamos anotarlo directamente al ser 8 valores
# partits<-c("PP","PSPV","COMPROMÍS","VOX","PODEMOS","Cs","EUPV","RESTA")
```
Los visualizamos en formato de tabla de RMarkdown
```{r 4b, echo=TRUE}

kable(partits, caption = "CANDIDATURAS")
```

# 3. CÁLCULO DE VALORES DE MEDIDAS de TENDENCIA CENTRAL y DISPERSIÓN

1.- Media o promedio aritmético
2.- Máximos
3.- Míninos
4.- Rango de variación

```{r 5, echo=TRUE}
mean(df_autonomicas)
media<-summarise_at(df_autonomicas,partits,mean())
mitjana<-summarise_at(df_autonomicas,partits,min())
maxims<-summarise_at(df_autonomicas,partits,max)
minims<-summarise_at(df_autonomicas,partits,~min(.[. != 0])) #Descartamos los 0
rangodevariacion<-maxims - minims
```

## 3.1 Creamos un data frame. cada vector anterior será una columna

```{r 5b, echo=TRUE}
df_resultats<-rbind(mitjana)
df_resultats<-rbind(df_resultats,maxims)
df_resultats<-rbind(df_resultats,minims)
df_resultats<-rbind(df_resultats,rangodevariacion)
#Redondeamos los valores a enteros ( son votos) 
df_resultats<-df_resultats %>% mutate_at(partits, as.integer)
```
## 3.2 Añadimos al final del data frame una columna con el nombre del "cálculo"

```{r 5c, echo=TRUE}
df_resultats<-cbind(df_resultats,ESTADÍSTICA=c("MEDIA","MÁXIMO","MÍNIMO","RANGO"))
```

```{r 5d, echo=TRUE}
# la resituamos en la posición 1 ( estática)
df_resultats<-df_resultats %>% select("ESTADÍSTICA",everything())
```

## 3.3 Eliminamos la columna que no necesitamos

La columna RESTA es la que contiene los datos de el "resto de partidos". Como está en la útlima posición, usamos la función *length* que nos dará su índice y con el *-* se elimina.

```{r 5d2, echo=TRUE}
df_resultats <- df_resultats[,-length(df_resultats)]
```

## 3.3 Imprimimos en Markdown una tabla con los resultados
```{r 5e, echo=TRUE}
knitr::kable(df_resultats, caption = "ESTADÍSTICA SAFOR")
```

# 4. GRÁFICOS Y TABLAS 

Vemos a continuación los gráficos y tablas de daraso a nivel de agregación de candidatura.
Creamos por cada partido (columna del *df_resultats*):

* Un data_frame
* Un gráfico
* Una tabla


```{r 6, results='asis'}
# Recorremos las columnas del data frame correspondientes a candidaturas ( >2)
# Creamos un data frame en cada iteración
for ( i in 2:length(df_resultats)){
     df_estPartit<- data.frame(
         ESTADÍSTICA=df_resultats$ESTADÍSTICA,
         VALORS=df_resultats[,i],
         PARTIT=colnames(df_resultats[i])
     )

# EN UN GRAFICO
barplot(df_estPartit$VALORS, 
        main=paste("Valores estadísticos de",df_estPartit$PARTIT[1]),
        names.arg=df_estPartit$ESTADÍSTICA,
        col=c("gray","green","red","#ede12e"),
        ylab="VOTOS")


# EN UNA TABLA
#Quitamos la columna que repite el nombre ( estético), lo guardamos antes
candidatura<-df_estPartit$PARTIT[1]
df_estPartit <- df_estPartit[, !(names(df_estPartit) %in% "PARTIT")]
knitr::kable(df_estPartit, caption = paste( "ESTADÍSTICA SAFOR", 
                        candidatura )) %>% print()

}

```

# 5. GUARDAR DATA FRAME EN FICHEROS DE DIFERENTES FORMATOS

## 5.1 Guardar datos en formato .xlsx (MS Excel)

Se instala el paquete solo si hace falta
```{r 7, echo=TRUE}
if (!require("xlsx")) {install.packages("xlsx")}
```
Se creará un fichero de tipo MS Excel: *resultats.xlsx* 

```{r 8, echo=TRUE}

# Si existe lo borramos 
if (file.exists("resultats.xlsx")){file.remove("resultats.xlsx")}
# Ahora, lo creamos de nuevo
write.xlsx(df_resultats, file = "resultats.xlsx", sheetName = "resultats", append = FALSE)

```

## 5.2 Añadiendo una hoja en un ficher xlsx existente
Aquí añadiremos una página más a un fichero MS Excel existente (append=TRUE). Si *ficheroAnterior.xlsx* no existe dará error.


```{r 9, eval=FALSE}

# El objeto Workbook de R sirve para carcar un xlsx MS Office 2007 o posterior
# Lo cargamos en la varibel de este tipo wb con la función pertinente 
# No comporbamos la existencia del fichero pues se ha creado en el anterior chunk
wb<-loadWorkbook("resultats.xlsx")
# Comprobamos que NO exista la página 
if ("resultats" %in% names(wb)) {
  # Si la hoja existe, se remobra (no se puede borrar, tiene que existir al menos 1)
   renameWorksheet(wb, "resultats", "resultatsOLD")

}

# write.xlsx(df_resultats, file="resultats.xlsx", sheetName="resultats1", append=TRUE)
addWorksheet(wb, "resultats")
writeData(wb, sheet = "resultats", x = df_resultats)
saveWorkbook(wb, file="resultats.xlsx",overwrite = TRUE) #guardamos en disco (fichero)

```


## 5.3 Guardar datos en formato .dta / Stata.
```{r 10, echo=TRUE}
if (!require("foreign")) {install.packages("foreign")}
write.dta(df_resultats, "resultats.dta")
```



## 5.4 Guardar datos en formato .csv
```{r 11, echo=TRUE}
if (!require("tidyverse")) {install.packages("tidyverse")}
write_csv(df_resultats, "resultats.csv")
```



## 5.5 Guardar datos en formato .sav / SPSS
```{r 12, echo=FALSE}
if (!require("haven")) {install.packages("haven")}
write_sav(df_resultats, "resultats.sav")
```

```{r 12b, echo=TRUE, eval=FALSE}
if (!require("haven")) {install.packages("haven")}
write_sav(df_resultats, "resultats.sav")
```
## 5.6 Guardar y abrir datos en formato RStudio.

Quizás estemos más habituados a compartir los datos en formatos "comma separated values" u hojas de cálculo. Ahora conoceremos otro tipo de fichero que se manejan muy fácilmente. No requieren librería, pues R ya incorpora funciones para su manejo.

> 
> RData - permite guardar más de una base de datos en un mismo archivo.

```{r 13, echo=TRUE}
save(df_resultats, file="resultats.RData")
```
## 5.7 Lectura de datos RData
El parámetro *verbose=TRUE* es opcional. Sirve para que en la carga (lectura) nos muestre los datos (dataframe en este caso) existentes en el fichero de tipo *.Rdata*.
en nuestro ejemplo vemos que contiene el dataframe: *df_resultats*

```{r 14, echo=TRUE}
load("resultats.RData",verbose=TRUE)
```

## 5.8 RDS - guarda un solo archivo de datos
```{r 15, echo=TRUE}
saveRDS(df_resultats, "resultats.rds")
```

## 5.9 Lectura de datos RDS
```{r 16, echo=TRUE}
df_resultats2 <- readRDS("resultats.rds")
```

